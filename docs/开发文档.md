# 开发文档（基于现有逻辑）

## 概览
- Mirai Console 插件，入口 `OneMoreRun`，加载配置、数据源后注册权限与事件。
- 核心玩法：群聊内组队（3 人且职业类型不得重复）→ 选择副本与难度 → 回合制战斗（玩家顺序→Boss）→ 掉落与结算。
- 数据持久化依赖 HibernatePlus，当前仅支持 MySQL（配置为其他类型会直接退出）。

## 初始化流程
- `DataConfig`：自动保存配置，含 DB 驱动/地址/账号/密码；默认驱动为 SQLITE，但 `DataManager` 强制要求 `MYSQL`，否则关闭 Mirai。
- `DataManager.init`：构建 HibernatePlus 配置，扫描实体包 `cn.chahuyun.omr.entity.data`，加载数据库。
- `OMRLoader.loader`：按序加载注册器  
  - 效果 `DodgeEffectRegistrar`、`PoisonEffectRegistrar`  
  - 装备 `NoviceEquipmentRegistrar`  
  - 技能 `FireballSkillsRegistrar`  
  - 副本 `StartingZoneRegistrar`
- `OMRAuth.loader`：向授权中心注册权限码及权限组（基础/用户/游戏）。

## 核心领域模型
- `GameEntity`：战斗体基类，含当前属性、技能、效果、伤害记录。
- `Player`、`Boss`：实体实现；`Player` 持有职业 `Occupation`（类型 Tank/DPS/Support/Healer）。
- `Dungeon`：抽象副本，定义 Boss 属性、技能、掉落、必掉；`toBoss(difficulty)` 生成对应 Boss。
- `GameTeam`：群内队伍状态（玩家列表、副本、难度、战斗中标记）；`start()` 转为 `GameProcess` 协程。
- `GameProcess`：战斗主循环  
  - 回合序列 1/2/3 为玩家，4 为 Boss；循环直到 Boss HP ≤ 0。  
  - 回合前：预留加载装备/技能/环境加成（未实现）。  
  - 玩家无技能时普通攻击；Boss 无技能时优先打 Tank，否则随机。  
  - 结算：按防御减伤、效果触发 `Trigger.ON_DAMAGE_CALCULATE`；记录消息并轮转回合。
- `Impact`：一次数值影响（伤害/治疗），含来源、目标、类型、最终值。
- 掉落 `Loot`/`LootHeap`：权重随机，可产生装备/金币/经验/空掉落；装备通过 `EquipmentFactory.take` 生成（随机装备会持久化元数据）。

## 装备系统
- `Equipment`：抽象装备，含部位、套装、属性与效果生成器；支持随机属性与克隆序列化。
- `EquipmentFactory`：  
  - `register` 注册原型并登记序列化类型。  
  - `take(code)`：若为随机实例，克隆并生成唯一 metaCode，落地到 `EquipmentRandomData`；否则返回原型。  
  - `serialize/deserialize`：仅存/取元数据（属性+效果），基础模板来自已注册原型。
- 内置新手装备：  
  - `NoviceHelmet`（DEF+1，套装前缀）。  
  - `NoviceRing`（随机 ATK/DEF +3~5，随机装备示例）。  
  - `NoviceSuit`：5 件触发 ATK+5、DEF+5（示例）。

## 技能与效果
- `Skills`：定义类型（职业/自定义/被动）、目标类型、冷却；暴露效果 codes 与自定义伤害配置。
- `SkillsFactory`：注册与获取；内置火焰术两版：玩家版（1.5×ATK，目标 Boss），Boss 版（1.2×ATK，目标全体玩家）。
- `Effect`：定义类型（BUFF/DEBUFF/ONLY_*）、触发时机（副本开始/回合开始/技能释放/伤害计算/回合结算/副本结束）、优先级、可叠加策略。
- `EffectFactory`：注册与按 code 取/克隆；`take(code, value?)` 支持覆写数值。
- 内置效果：  
  - `DodgeEffect`：伤害计算时按概率闪避（非真实伤害）。  
  - `PoisonEffect`：回合结算时按攻击力×系数造成持续伤害（加入 `damageTaken`）。

## 副本与掉落
- `StartingZone` 示例副本：  
  - 难度 1/2/3 的 Boss 属性递增；难度 3 会携带火球技能 code。  
  - 掉落：难度 1/2 掉新手头盔；难度 3：头盔/空/新手戒指权重分布。
- 可扩展：实现新的 `Dungeon` 子类并在注册器中 `DungeonFactory.register(...)`。

## 事件与权限
- 指令监听基于 `@MessageAuthorize`：  
  - `createTeam`（"创建队伍"/"开队"/"来一把"）：建队并 3 分钟超时解散。  
  - `addTeam`（"加入"/"加入队伍"/"进组"/"来"/"join"）：职业类型不得重复，满 3 人后队长 30s 内回复 “副本名 难度” 启动战斗。
- 权限要求：均需 `OMRPerm.GAME`（基础/用户权限也可用于扩展）。

## 用户与持久化
- 实体：  
  - `PlayerUser`：基础属性、职业、装备栏 id、技能栏 id 等。  
  - `UserEquipment`：各部位装备 code；提供部位取装备与全列表。  
  - `UserSkills`：职业/主/副/被动技能 code。
- `UserManager`：从事件或 User 取玩家；不存在则初始化默认属性与空装备/技能记录。

## 配置与依赖
- 配置文件 `data-config.yml`（自动生成）：`type` 需设为 `MYSQL`，并配置 `url/user/password`。
- 依赖 HuYanAuthorize 权限框架、HibernatePlus、Mirai Console。

## 当前空实现 / TODO
- `GameProcess` 中装备/技能/环境加成加载、Boss/玩家技能释放逻辑未完成。
- 掉落的道具工厂（非装备）未实现。
- 事件 `MessageListening` 为空。
- 权限组父子关系被注释，可按需恢复。

## 示例代码（快速参考）
- 副本注册与多难度配置  
\n```12:50:src/main/kotlin/cn/chahuyun/omr/dungeon/StartingZone.kt
object StartingZoneRegistrar {
    init {
        val startingZone1 = StartingZone(
            STARTING_ZONE,
            name = "新手村",
            bossName = "哥布林",
            bossDescription = "一只红色的哥布林",
            bossProperty = mapOf(
                1 to create(hp = 500, atk = 5, def = 5, crit = 1, critDamage = 120),
                2 to create(hp = 750, atk = 15, def = 7, crit = 1, critDamage = 120),
                3 to create(hp = 1000, atk = 25, def = 10, crit = 3, critDamage = 130),
            ),
            skills = mapOf(
                3 to listOf(CodesSFireball.FIREBALL_SKILLS_BOSS_120)
            ),
            dropLoot = mapOf(
                1 to buildLootHeapList { lootHeap { equipment(100, CodesEQNovice.NOVICE_HELMET) } },
                2 to buildLootHeapList { lootHeap { equipment(100, CodesEQNovice.NOVICE_HELMET) } },
                3 to buildLootHeapList {
                    lootHeap {
                        equipment(70, CodesEQNovice.NOVICE_HELMET)
                        none(19)
                        equipment(11, CodesEQNovice.NOVICE_RING)
                    }
                }
            ),
            certainlyLoot = emptyMap(),
        )

        DungeonFactory.register(startingZone1)
    }
}
\n```

- 装备定义（固定属性 & 套装）  
\n```78:111:src/main/kotlin/cn/chahuyun/omr/equipment/NoviceEquipment.kt
@SerializeEquipment
@EquipmentDiscriminator(NOVICE_HELMET)
class NoviceHelmet() : Equipment(
    code = NOVICE_HELMET,
    name = "头盔",
    description = "村好盔",
    slot = EquipmentSlot.HEAD,
    suit = NoviceSuit(),
    special = false,
) {
    override val generateEffects: () -> List<Effect> = { emptyList() }
    override val generateProperties: () -> List<Property> = { listOf(Property(1, PropertyType.DEF)) }
}
\n```

- 技能注册（玩家版 & Boss 版）  
\n```9:24:src/main/kotlin/cn/chahuyun/omr/skills/FireballSkills.kt
object FireballSkillsRegistrar {
    init {
        val fireballSkills = FireballSkills(
            FIREBALL_SKILLS_150, "火焰术", "发射一枚火球攻击对方",
            SkillsType.CUSTOM, TargetType.BOSS, 2
        )
        SkillsFactory.register(fireballSkills)

        // Boss 版火焰术：面向玩家群体
        val bossFireball = FireballSkills(
            FIREBALL_SKILLS_BOSS_120, "火焰术·首领", "首领发射大火球攻击玩家",
            SkillsType.CUSTOM, TargetType.ALL_PLAYERS, 2
        ) { selfAtk -> (selfAtk * 1.2f).roundToInt() }
        SkillsFactory.register(bossFireball)
    }
}
\n```

- 效果定义（闪避，伤害结算前修改伤害）  
\n```12:47:src/main/kotlin/cn/chahuyun/omr/effect/DodgeEffect.kt
object DodgeEffectRegistrar {
    init {
        val ordinaryDodgeEffect = DodgeEffect(DODGE_EFFECT_10, "普通闪避", value = 0.1f)
        EffectFactory.register(ordinaryDodgeEffect)
    }
}

class DodgeEffect(
    code: String, name: String, duration: Int = -1, priority: Int = 100,
    override val smallComposition: String = "闪避!",
    override var value: Float,
) : Effect(code, name, EffectType.BUFF, Trigger.ON_DAMAGE_CALCULATE, duration, priority) {
    override fun onTurn(entity: GameEntity, process: GameProcess) {
        entity.damageTaken.forEach {
            if (it.damageType != DamageType.PURE && RandomUtil.random(value)) {
                it.finalValue = 0
                process.record.add("${it.source.name} 对 ${it.targets.joinToString(",") { target -> target.name }} 的伤害被闪避了! ")
            }
        }
    }
}
\n```

- 战斗中释放技能与目标选择  
\n```291:307:src/main/kotlin/cn/chahuyun/omr/game/GameProcess.kt
private fun GameProcess.castSkill(caster: GameEntity, skill: Skills) {
    val targets = selectTargets(skill, caster)

    // 处理效果附加
    skill.getEffectCodes().forEach { code ->
        val effect = EffectFactory.take(code)
        targets.forEach { target ->
            target.effects.add(effect)
            effect.onApply(target, this)
        }
    }

    // 处理伤害/治疗影响
    skill.getImpactConfigs().forEach { config ->
        val base = config.calculateBaseValue(caster, targets).toLong()
        val impact = Impact(base, "技能 ${skill.name}", caster, targets, config.damageType)
        caster.damageDealt.add(impact)
    }

    record.add("${caster.name} 释放了技能 ${skill.name}")
}
\n```

## 扩展指引
- 新副本：继承 `Dungeon`，提供属性/技能/掉落映射，注册到对应 Registrar。
- 新装备：继承 `Equipment` 并使用 `@SerializeEquipment` + `@EquipmentDiscriminator`，在 Registrar 注册。
- 新技能/效果：实现类并通过 `SkillsFactory.register` / `EffectFactory.register`，在加载器按需调用。
- 战斗规则：补充 `GameProcess` 中 TODO 逻辑，确保触发时机使用 `Trigger` 枚举。

## 拓展开发规范（副本、装备、技能、效果）

更多细节与示例请参考：
- 副本：`docs/副本开发指南.md`
- 装备：`docs/装备开发指南.md`
- 技能：`docs/技能开发指南.md`
- 效果：`docs/效果开发指南.md`

### 副本拓展
- 继承 `Dungeon`，实现 `bossProperty`（难度→属性）、`skills`（难度→技能 codes）、`dropLoot`、`certainlyLoot`。
- 在对应 Registrar（如 `StartingZoneRegistrar`）实例化并 `DungeonFactory.register(...)`。
- 规范：副本 code 唯一，命名示例 `D-xxxx-n`；确保 `bossProperty` 覆盖可选难度，否则 `toBoss` 会抛异常。

### 装备拓展
- 继承 `Equipment`，添加 `@SerializeEquipment` 与 `@EquipmentDiscriminator("<code>")`，在 Registrar 中 `EquipmentFactory.register(...)`。
- 必填：唯一 code、部位 `slot`，实现 `generateProperties`/`generateEffects`（可返回空列表），若为随机属性请设 `random=true`。
- 若需要套装效果：自定义 `Suit`，在装备实例传入；确保套装效果/属性按件数映射。
- 命名规范：code 建议 `E-<theme>-<name>`，随机实例会自动追加短 id；描述与 `smallComposition` 保持简洁。

### 技能拓展
- 继承 `Skills`，在 Registrar 中 `SkillsFactory.register(...)`；定义 `SkillsType`、`TargetType`、冷却等。
- 覆写 `getEffectCodes()`（返回需要附加的效果 codes）与 `getImpactConfigs()`（定义伤害/治疗公式、类型）。
- 命名规范：code 建议 `S-<theme>-<power>`，`TargetType` 需与预期目标一致，当前简化版会取首个技能施放。

### 效果拓展
- 继承 `Effect`，在 Registrar 中 `EffectFactory.register(...)`；设置类型（BUFF/DEBUFF/ONLY_*）、触发时机 `Trigger`、优先级。
- 可覆写 `onApply/onRemove/onTurn/applyImpact/merge`，按触发场景实现逻辑；`value` 作为强度参数，可在 `EffectFactory.take(code, value)` 时覆盖。
- 命名规范：code 建议 `effect-<type>-<source>-<value>`，确保唯一；描述与 `smallComposition` 清晰说明触发与效果。

